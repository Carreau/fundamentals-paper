\section{Methodology and Implementation}
% What were the methods used?
% How was the problem designed?
% Driving concepts
% Equations
% Figures

A modular, agent-based is an ideal approach for solving complicated
physics-dependent supply chain problems involving material routing, facility
deployment, regional and institutional hierarchies.

\subsection{Framework Structure}
% (OO, cpp, xml, backends, inheritances, mixins, generic apis, etc.)

Agent-based modeling is inherently object oriented. 

The core of the simulator creates a set of key classes on which agent plugins 
are based. In addtion, a set of key tools are also provided, to enrich the API 
and provide a robust suite of behaviors for the developer.

<diagram of core, modules, toolkit, etc>

Agent plug-ins utilize the generic core API to interact with one another. 
Mainly they do this by trading resources. 

<diagram of black box facilities>

\subsection{Cluster-Ready Software}

\Cyclus is primarily written in \texttt{C++}, and support is currently provided
for Linux-based (including Ubuntu and OSX) platforms. Furthermore, the core
infrastructure and related archetypes are free and open-source, BSD-3-clause
licsened. No part of \Cyclus is proprietary or based on commercial, off the
shelf (COTS) software. Accordingly, it can be easily deployed on large compute
systems, such as high-throughput computing (HTC) systems.

Cyclopts (\TODO{cite}), a proof of principle design and implementation of such a
system, uses UW-Madison's HTCondor HTC infrastructure to perform sensitivity
studies on \Cyclus' resource exchange optimization solvers. To date, it has been
used run over $10^4$ jobs, or (\TODO{compute time}) total compute hours, using
the \Cyclus library via its resource exchange API.

\subsection{Dynamically Loadable Libraries}
% (diagram)

A key innovation that has previously not been implemented in nuclear fuel cycle 
simulators in the literature is implementing this generic API and modular 
architecture into a suite of dynamically loadable ``plug-in'' libraries. 
This is implemented largely through a clean API and a modern build system.

Dynamically-loadable libraries are the primary mechanism for extending \Cyclus' capability. 
This approach provides encapsulation: the core of the code operates
completely independently from the individual libraries. Thus, any
customization or extension is implemented only in the loadable
library. 

This approach allows efficient, targeted contribution to the ecosystem of libraries.  The 
scientist-developer can therefore focus on generating a model within their 
sphere of expertise, while relying on the model contributions of others to fill 
in the other technologies.  This strategy also allows individual developers to
explore different levels of complexity within their archetypes, including
wrapping other simulation tools as loadable libraries within the \Cyclus
framework.

A secondary benefit is the ability for
contributors to choose different distribution and licensing strategies
for their contributions. By allowing models to have varied
availability, the security concerns of developers can be
assuaged (See Figure \ref{fig:modifiedopen}).

\begin{figure}[htbp!]
\begin{center}
\includegraphics{./images/modifiedopen.eps}
\end{center}
\caption{The \Cyclus framework enables fully open, partially open, and fully
closed collaborations\cite{wilson_cyclus:_2012}.}
\label{fig:modifiedopen}
\end{figure}

In particular, since the clean plug-in architecture loads libraries without any
modifications to the \Cyclus kernel, closed-source archetypes can be used with
the simulator alongside open-source archetypes. This architecture therefore
allows closed-source libraries (e.g., those representing sensitive nuclear
processes and subject to export control) to be developed and licensed privately.

This last benefit of dynamically-loadable libraries addresses
another goal of \Cyclus: ubiquity amongst its potential user base. By
engineering \Cyclus to easily handle varying levels of complexity, a single
simulation engine can be used by both users interested in big-picture policy
questions as well as users focused on more detailed, technical
analyses.

\subsection{Agent Interchangability}\label{sec:interchangeability}

A key compontent of the \Cyclus kernel architecture is the ability for
implementations of actors in a given simulation to be easily
interchanged. Critically, this novel functionality enables the comparison
between agent implementations. For example, a low-physics-fidelity
implementation of a reactor can be comparied to an implementation with higher
physics fidelity, allowing an analyst to discern the effect of reactor physical
fidelity on a given fuel cycle. 

Interchangability is accomplished by providing APIs that define agent-to-agent
interaction and agent-to-environment interaction, primarily through the
\Class{Agent} and \Class{Trader} interfaces. The \Class{Agent} interface
provides a notion of parent-child hierarchichal relationship, where parents can
choose to \textit{build} child agents and \textit{decommission} child
agents. The \Class{Trader} interface allows agent-agent interaction through the
trading of \Class{Resource}s. Usabe archetypes in a \Cyclus simulation must
implement the \Class{Agent} interface and may optionally implement the
\Class{Trader} interface. For example, a \Class{Region} implements only the
\Class{Agent} interface, whereas a \Class{Facility} implements both the
\Class{Agent} and \Class{Trader} interface, allowing any \Class{Facility} to
trade with another \Class{Facility}.

\subsection{Regions, Institutions, and Facilities}

\Cyclus provides a novel representation of entities in the nuclear fuel cycle,
including facilities, institutions managing those facilities, and regions. While
some simulators (\TODO{cite DESAE}) have provided a notion of static regional
effects, \Cyclus allows for both regions and institutions to be first-class
actors in simulated fuel cycles.

The basic interaction models for each entity is implemented by a corresponding
archetype class in \Cyclus, i.e., the \Class{Region} class, \Class{Institution}
class, and \Class{Facility} class. Archetype developers can then build on the
provided functionality by subclassing the appropriate class.

\Cyclus implements a Region-Institution-Facility (RIF) relationship through the
parent-child hierarchy described in \S \ref{sec:interchangeability}, where
regions are the parents of institutions which are, in turn, the parents of
facilities. In other words, RIF hierarchies form a directed acyclic graph (DAG),
with regions as root nodes and facilities as leaf nodes.

Two primary consequences arise from this structure. First, institutions are
responsible for building and decommissioning facilities. Accordingly, advanced
logic regarding building and decommissioning can be obtained by subclassing the
\Class{Institution} interface. Second, the \Class{Facility} class implmenets the
\Class{Trader} interface, and thus institutions and regions, respectively, can
adjust the resource flow preferences of their managed facilities. Importantly,
this novel capability allows for the modeling of preferential regional trading
of resources (e.g., tariffs) as well as preferential institutional trading
(e.g., long-term contracts).

\subsection{Discrete Object Tracking}
% Resources, Materials (note isotope tracking, decay behavior)

TODO: add blurb about discrete agent/facility tracking.

In Cyclus, agents can transfer discrete resource objects between each other.
Cyclus supports two types of resources:

\begin{itemize}

  \item Materials: These represent typical nuclear materials with
      nuclide-based compositions.

  \item Products: These can represent any user-defined thing - e.g. carbon
      credits, build permits, employees, etc.

\end{itemize}

All operations performed on every resource object (splitting, combining,
decay, etc.) are tracked in detail.  This information includes the creating
agent for when resources are newly created and introduced into the simulation.
The parentage of each resource is also tracked. This makes it possible to
follow the travel history of resource objects as they are transferred between
agents.

In large simulations there may be many material objects changing frequently.
Material decay can also contribute significantly to such changes.  In order to
help avoid unnecessary runtime performance and database space impacts,
compositions in Cyclus have some special features.  Compositions in Cyclus are
immutable.  This immutability allows multiple material objects to all hold
references to the same composition object safely.  When operations are
performed on a material that don't change the composition, any new resulting
materials hold a reference to the same, originating composition object.
Although the decay operation generates a new, separate composition (preserving
immutability), a reference to the new composition is placed in a cache shared
by the new an originating compositions. The next time the originating
composition is decayed, this cache will be checked for a prior calculation
with the same cumulative decay time.  If one exists, the cached composition is
used.  This cache is shared by all compositions that transitively come from
the same origin.  Composition immutability in concert with decay history
caching help eliminate many redundant decay calculations in addition to
reducing the total number of composition objects.  Since each composition
object is only recorded in the database once, significant space savings also
occurs.

\subsection{Toolkit}
% library of tools
% contributions to the toolkit
% place for metrics

The toolkit is a place for developers and users to contribute common-use tools 
for calculating metrics, managing process physics, and handling data.

This was implemented by liberal use of namespaces and is populated with an
introductory suite of useful tools, including helper classes for managing
facility deployment, minimum cost facility deployment decision making, and for
enrichment-related calculations.

\subsection{Cycamore}
% base modules

Cycamore contains a number of useful facility models that are a mere base-set.
Additional modules are needed for interesting fuel cycle simulation. However,
simple, once-through fuel cycles can be generated with Cycamore and Cyclus alone.

<diagram of a possible Cycamore-only simulation>
